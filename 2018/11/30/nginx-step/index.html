<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> nginx 的一些概念和解析 · Olier</title><meta name="description" content="nginx 的一些概念和解析 - TbhT"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/hermes.css"><link rel="search" type="application/opensearchdescription+xml" href="http://olierjs.github.io/atom.xml" title="Olier"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Olier" type="application/atom+xml">
</head><body><div class="wrap"><header><a class="logo-link" href="/"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">BLOG</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/olierjs" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives/" target="_self">ARCHIVE</a></li><li class="nav-list-item"><a class="nav-list-link" href="/atom.xml" target="_self">FEED</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">nginx 的一些概念和解析</h1><div class="post-info">2018年11月30日</div><div class="post-content"><h1 id="nginx-解析过程"><a href="#nginx-解析过程" class="headerlink" title="nginx 解析过程"></a><code>nginx</code> 解析过程</h1><ul>
<li>ngx_http_process_request_line</li>
</ul>
<blockquote>
<p>HTTP 请求行之前的处理，主要获取 path，method等信息</p>
</blockquote>
<pre><code>- ngx_http_read_request_header

- ngx_http_parse_request_line

- ngx_http_process_request_headers
</code></pre>
<blockquote>
<p>HTTP 请求头的处理</p>
</blockquote>
<pre><code>- ngx_http_read_request_header

- ngx_http_parse_header_line

- 解析到 `header` 名称，在 `ngx_http_headers_in` 中保存，是一个哈希表，有对应的handler，
</code></pre>
<p>对某些特殊的请求头会进行处理</p>
<ul>
<li>ngx_http_process_request</li>
</ul>
<blockquote>
<p>设置当前的读写事件处理函数为 <code>ngx_http_request_handler</code> , 这个 <code>handler</code> 会根据当前的事件是 <code>read_event_handler</code> 的 还是 <code>write_event_handler</code> 来处理，但是在这个阶段，请求头已经处理完成了，并且不会先处理请求体，所以此时会设置 <code>read_event_handler</code> 为<code>ngx_http_block_reading</code>，也就是暂时不读取数据了。</p>
</blockquote>
<ul>
<li>ngx_http_handler</li>
</ul>
<blockquote>
<p>设置 <code>write_event_handler</code> 为 <code>ngx_http_core_run_phases</code>，这个<code>handler</code>用来产生数据, 最终产生的数据会放在<code>ngx_http_request_t</code> 的 <code>headers_out</code> 中。</p>
</blockquote>
<ul>
<li>ngx_http_header_filter</li>
</ul>
<blockquote>
<p>遍历所有的响应头，最终输出的响应头在一个连续内存中</p>
</blockquote>
<ul>
<li><p>ngx_body_filter</p>
</li>
<li><p>ngx_http_write_filter</p>
</li>
</ul>
<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><ul>
<li>keepalive  </li>
</ul>
<blockquote>
<p>HTTP 1.0 协议中，响应头中的 <code>content-length</code> 如果指定了，那么客户端就按照这个长度进行数据读取，如果没有指定，就会等待服务端主动断开<br>HTTP 1.1 协议中，如果 <code>transfer-encoding</code> 为 <code>chunked</code>传输，则表示<code>body</code>是流式传输，会被分成多个块，每块的开始会标识出当前的长度。<br>如果有 <code>content-length</code>且是非<code>chunk</code>出书，则会按照这个来进行接收数据；两者都没有，则由服务端主动断开连接。</p>
</blockquote>
<ul>
<li>pipe</li>
</ul>
<blockquote>
<p>流式处理请求，客户端不用等请求完就可以发送下一个请求，服务端在收到请求后，会先放在buffer中，如果buffer中有数据，那么会继续当做请求处理。</p>
</blockquote>
<ul>
<li>linger_close</li>
</ul>
<blockquote>
<p>某些情况下会出现，执行完 <code>write</code> 系统调用后，数据在tcp的write buffer中，如果直接执行<code>close</code> 系统调用，那么系统会检查 tcp 的 read buffer<br>中是不是还有数据，如果有数据，则会认为客户端又发送过来消息，则会reset掉这些buffer，然后丢弃掉 write buffer 中的东西；如果没有数据，那么才会<br>进行正常的4次分手连接。故，设置一个超时时间用来读取客服端发送过来的数据。</p>
</blockquote>
<h1 id="nginx-的-配置系统"><a href="#nginx-的-配置系统" class="headerlink" title="nginx 的 配置系统"></a>nginx 的 配置系统</h1><h2 id="nginx-的指令上下文"><a href="#nginx-的指令上下文" class="headerlink" title="nginx  的指令上下文"></a>nginx  的指令上下文</h2><ul>
<li><p>main: nginx在运行时与具体业务无关的一些参数，比如什么工作进程数，运行的身份等</p>
</li>
<li><p>http: 与提供http服务相关的一些配置参数。比如是否使用 keepalive， 是否进行gzip压缩等</p>
</li>
<li><p>server： 支持多个虚拟主机。 灭一个虚拟主机对应一个server配置项</p>
</li>
<li><p>location： http服务中， 某些特定的url对于英的一系列配置项。</p>
</li>
<li><p>mail： 实现email相关的 <code>SMTP/IMAP/POP3</code>代理时，共享的一些配置项。</p>
</li>
</ul>
<blockquote>
<p>指令上下文， 可能有包含的情况出现。例如：通常http上下文和mail上下文一定是出现在main上下文里的。例如，如果http服务支持多个虚拟主机，那么在<br>http上下文里，会出现多个server上下文：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">user nobody;</span><br><span class="line">worker_processes 1;</span><br><span class="line">error_log logs/error.log info;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections 1024;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name www.example.com;</span><br><span class="line">        access_log  logs/example.log main;</span><br><span class="line">        location / &#123;</span><br><span class="line">            index index.html;</span><br><span class="line">            root /var/www/example.com/index.html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name 1.example.com;</span><br><span class="line">        access_log  logs/1.example.com main;</span><br><span class="line">        location / &#123;</span><br><span class="line">            index index.html;</span><br><span class="line">            root /var/www/1.example.com/index.html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mail &#123;</span><br><span class="line">    auth_http   127.0.0.1:80/auth.php;</span><br><span class="line">    pop3_capabilities &quot;TOP&quot; &quot;USER&quot;;</span><br><span class="line">    imap_capabilities  &quot;IMAP4rev1&quot;  &quot;UIDPLUS&quot;;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        listen     110;</span><br><span class="line">        protocol   pop3;</span><br><span class="line">        proxy      on;</span><br><span class="line">    &#125;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen      25;</span><br><span class="line">        protocol    smtp;</span><br><span class="line">        proxy       on;</span><br><span class="line">        smtp_auth   login plain;</span><br><span class="line">        xclient     off;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="http-请求的处理流程"><a href="#http-请求的处理流程" class="headerlink" title="http 请求的处理流程"></a>http 请求的处理流程</h1><p>当nginx读取到一个<code>HTTP Request</code>的<code>header</code>的时候， <code>nginx</code> 首先查找与这个请求关联的虚拟主机的配置。然后进行一下阶段的处理：</p>
<ul>
<li><p>NGX_HTTP_POST_READ_PHASE</p>
</li>
<li><p>NGX_HTTP_SERVER_REWRITE_PHASE</p>
</li>
<li><p>NGX_HTTP_FIND_CONFIG_PHASE</p>
</li>
<li><p>NGX_HTTP_REWRITE_PHASE</p>
</li>
<li><p>NGX_HTTP_POST_REWRITE_PHASE</p>
</li>
<li><p>NGX_HTTP_PREACCESS_PHASE</p>
</li>
<li><p>NGX_HTTP_ACCESS_PHASE</p>
</li>
<li><p>NGX_HTTP_POST_ACCESS_PHASE</p>
</li>
<li><p>NGX_HTTP_TRY_FILES_PHASE</p>
</li>
<li><p>NGX_HTTP_CONTENT_PHASE</p>
</li>
<li><p>NGX_HTTP_LOG_PHASE</p>
</li>
</ul>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2020/03/14/rxjs-fetch/">上一篇</a><a class="next" href="/2018/09/03/babel-step/">下一篇</a></div><div class="copyright"><p>© 2019 - 2022 <a href="http://olierjs.github.io">TbhT</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/claymcleod/hexo-theme-hermes" target="_blank">hexo-theme-hermes</a>. </p><p>Logo made by <a target="_blank" rel="noopener" href="https://www.flaticon.com/authors/freepik">Freepik</a> from <a target="_blank" rel="noopener" href="https://flaticon.com">www.flaticon.com</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=GTM-5K584LS"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'GTM-5K584LS');</script></body></html>