<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> UI For React 模式 · Olier</title><meta name="description" content="UI For React 模式 - TbhT"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/hermes.css"><link rel="search" type="application/opensearchdescription+xml" href="http://olierjs.github.io/atom.xml" title="Olier"><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Olier" type="application/atom+xml">
</head><body><div class="wrap"><header><a class="logo-link" href="/"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a class="nav-list-link" href="/" target="_self">BLOG</a></li><li class="nav-list-item"><a class="nav-list-link" href="https://github.com/olierjs" target="_blank">GITHUB</a></li><li class="nav-list-item"><a class="nav-list-link" href="/archives/" target="_self">ARCHIVE</a></li><li class="nav-list-item"><a class="nav-list-link" href="/atom.xml" target="_self">FEED</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">UI For React 模式</h1><div class="post-info">2021年12月23日</div><div class="post-content"><blockquote>
<p>本文中的设计模式主要是针对React + hooks的设计模式。更多信息可以参考<a target="_blank" rel="noopener" href="https://www.patterns.dev/posts/singleton-pattern/">patterns.dev</a>。</p>
</blockquote>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>  在 <a target="_blank" rel="noopener" href="https://book.douban.com/subject/34262305/">设计模式：可复用面向对象软件的基础</a> 本书中提到的23种设计模式是OOP场景下的，虽然JS的面向对象做的并不是十分好，不过也有一些类似的场景可以复用这些模式。</p>
<h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><blockquote>
<p>在应用之间共享应用的全局状态</p>
</blockquote>
<p>  单例模式本身要求类的实例在某个范围或者全局是唯一的，最简单的方式其实就是通过一个模块导出一个唯一的实例，如果还需要有其他后置参数需要加入到整个实例中进行某些操作，那么则可以通过导出一些修改实例属性的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// some-module.js</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  #param1 = <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="title">change</span>(<span class="params">val</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.#param1 = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance = <span class="keyword">new</span> Singleton()</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> instance</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">changeParam1</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  instance.change(val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  单例模式某种程度上相当于一个，大号的全局变量，全局变量的优缺点它也会有。我想这也是在一些场景下，它被称作<code>反模式</code>的原因。单例模式在某些场景下会适用，可以减少内容和网络的适用。上面的例子有点过于炫技，其实也可以使用 对象字面量 配合 <code>Object.freeze</code>来做单例模式。</p>
<p>  当然缺点是在测试的时候，可能需要在某个<code>describe</code> 完成后，重置当前的状态，并且多个测试之间最好不要并行测试。</p>
<p>  在 <code>React</code>中，使用<code>redux/context</code>这样的工具，从效果上也是和单例模式类似，可以从组件内全局接触。这种模式好的一点就是可以指定修改状态的方式，组件没法直接修改全局状态。</p>
<h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><blockquote>
<p>劫持和控制对原对象的操作</p>
</blockquote>
<p>  代理模式在js中非常常用，在 <code>ES5</code> 时期，<code>Vue2</code> 就借助 <code>Object.__defineGetter__, Object.__defineSetter__</code> 来劫持对象属性，来创建响应式的数据。在 <code>ES6</code> 中，加入了<code>Proxy</code> 来满足劫持的需求。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> personProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function">(<span class="params">obj, prop</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`The value of <span class="subst">$&#123;prop&#125;</span> is <span class="subst">$&#123;obj[prop]&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="function">(<span class="params">obj, prop, value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Changed <span class="subst">$&#123;prop&#125;</span> from <span class="subst">$&#123;obj[prop]&#125;</span> to <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    obj[prop] = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// try to use proxy</span></span><br><span class="line"></span><br><span class="line">personProxy.name;</span><br><span class="line">personProxy.age = <span class="number">2</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  代理模式在需要劫持数据的场景下是非常有用的，比如在做数据校验，以及在<code>typescript</code>中使用的装饰器，都是通过劫持属性对象来实现的。与<code>Proxy</code>搭配使用的另一个内建对象 <code>Reflect</code>。</p>
<p>  即，不直接通过 <code>obj[prop]</code>来访问，相反，通过<code>Reflect.get()/set()</code>来访问</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> personProxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(person, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="function">(<span class="params">obj, prop</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`The value of <span class="subst">$&#123;prop&#125;</span> is <span class="subst">$&#123;<span class="built_in">Reflect</span>.get(obj, prop)&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="function">(<span class="params">obj, prop, value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Changed <span class="subst">$&#123;prop&#125;</span> from <span class="subst">$&#123;obj[prop]&#125;</span> to <span class="subst">$&#123;value&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">Reflect</span>.set(obj, prop, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>  当然如果在proxy中过于重的逻辑处理，可能会对性能有影响。在 <code>Vue/React</code> 生态中，代理模式的使用，更多的还是在<br>库的层面使用。比如<code>mobx6</code>以后，也采用了<code>Proxy</code>来做相应式数据的更新。</p>
<h2 id="Provider-模式"><a href="#Provider-模式" class="headerlink" title="Provider 模式"></a>Provider 模式</h2><blockquote>
<p>将数据对多个子组件可见</p>
</blockquote>
<p>  在前端领域中，常常会有父组件的一部门数据需要给多个子组件可见。<code>React</code>中提供了<code>Context</code>这样的机制来实现 <code>Provider</code>模式。比如常见的换皮肤<br>的工作，就是可以通过 <code>Context</code> 来很方便的实现。</p>
<p>  典型的一个例子就是 <code>style-component</code>，</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; ThemeProvider &#125; <span class="keyword">from</span> <span class="string">&quot;styled-components&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [theme, setTheme] = useState(<span class="string">&quot;dark&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">toggleTheme</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTheme(theme === <span class="string">&quot;light&quot;</span> ? <span class="string">&quot;dark&quot;</span> : <span class="string">&quot;light&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&#123;</span>`<span class="attr">App</span> <span class="attr">theme-</span>$&#123;<span class="attr">theme</span>&#125;`&#125;&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">ThemeProvider</span> <span class="attr">theme</span>=<span class="string">&#123;themes[theme]&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Toggle</span> <span class="attr">toggleTheme</span>=<span class="string">&#123;toggleTheme&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">List</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">ThemeProvider</span>&gt;</span></span></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// li.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> styled <span class="keyword">from</span> <span class="string">&quot;styled-components&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">ListItem</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Li</span>&gt;</span></span></span><br><span class="line"><span class="xml">      Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod</span></span><br><span class="line"><span class="xml">      tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim</span></span><br><span class="line"><span class="xml">      veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea</span></span><br><span class="line"><span class="xml">      commodo consequat.</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">Li</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Li = styled.li<span class="string">`</span></span><br><span class="line"><span class="string">  <span class="subst">$&#123;(&#123; theme &#125;) =&gt; <span class="string">`</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">     background-color: <span class="subst">$&#123;theme.backgroundColor&#125;</span>;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">     color: <span class="subst">$&#123;theme.color&#125;</span>;</span></span></span></span><br><span class="line"><span class="string"><span class="subst"><span class="string">  `</span>&#125;</span></span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  provider 模式的优点有亮点：</p>
<ul>
<li><p>不用很繁琐的传入属性，减少重构代码出问题的几率</p>
</li>
<li><p>避免通过props传属性带来的 <code>反模式</code></p>
</li>
</ul>
<p>  当然缺点也很明显：</p>
<ul>
<li>过多的使用<code>context</code>，会使得只要一个 <code>context</code>进行了更新，那么整个组件就会进行 <code>re-render</code>，从而造成性能问题</li>
</ul>
<h2 id="prototype-模式"><a href="#prototype-模式" class="headerlink" title="prototype 模式"></a>prototype 模式</h2><blockquote>
<p>在相同类型的对象中，共享同一个属性或者方法</p>
</blockquote>
<p>  这种模式来说，js本身的继承机制就可以看作是最好的诠释。关于这块的文章已经非常多了，不在此赘述。</p>
<h2 id="Container-Presentational-模式"><a href="#Container-Presentational-模式" class="headerlink" title="Container/Presentational 模式"></a>Container/Presentational 模式</h2><blockquote>
<p>通过将视图层从应用逻辑中分离出来，从而将关注点分离</p>
</blockquote>
<p>  在 <code>React</code> 场景下，尤其是有了 <code>FC</code> 和 <code>hooks</code> 以后，要想将关注点分离，就是使用 <code>C/P</code> 模式。具体的表现则是</p>
<h4 id="container-component"><a href="#container-component" class="headerlink" title="container component"></a>container component</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// class component</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DogImagesContainer</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      <span class="attr">dogs</span>: []</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">componentDidMount</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    fetch(<span class="string">&quot;https://dog.ceo/api/breed/labrador/images/random/6&quot;</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">      .then(<span class="function">(<span class="params">&#123; message &#125;</span>) =&gt;</span> <span class="built_in">this</span>.setState(&#123; <span class="attr">dogs</span>: message &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">DogImages</span> <span class="attr">dogs</span>=<span class="string">&#123;this.state.dogs&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// fc </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDogImages</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [dogs, setDogs] = useState([]);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    fetch(<span class="string">&quot;https://dog.ceo/api/breed/labrador/images/random/6&quot;</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> res.json())</span><br><span class="line">      .then(<span class="function">(<span class="params">&#123; message &#125;</span>) =&gt;</span> setDogs(message));</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> dogs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="presentation-component"><a href="#presentation-component" class="headerlink" title="presentation component"></a>presentation component</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">DogImages</span>(<span class="params">&#123; dogs &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dogs.map(<span class="function">(<span class="params">dog, i</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;dog&#125;</span> <span class="attr">key</span>=<span class="string">&#123;i&#125;</span> <span class="attr">alt</span>=<span class="string">&quot;Dog&quot;</span> /&gt;</span></span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  在新的场景下，<code>hooks</code> 代替了原来的类组件的生命周期钩子函数，从而达到数据更新。视图分离最大的缺点就是，在一些细小的场景下，有点过于炫技。毕竟<br>不需要更改为无状态组件和hooks也可以达到同样的效果。</p>
<h2 id="observable-模式"><a href="#observable-模式" class="headerlink" title="observable 模式"></a>observable 模式</h2><blockquote>
<p>使用 <code>observables</code> 去通知所有的订阅者，当一个时间触发的时候。</p>
</blockquote>
<p>  也是很常见的模型了，<code>nodejs</code> 中的 <code>events</code> 模块就是典型的观察者模式。比如下方的一个最简化实现：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.observers = [];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">subscribe</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.observers.push(func);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">unsubscribe</span>(<span class="params">func</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.observers = <span class="built_in">this</span>.observers.filter(<span class="function"><span class="params">observer</span> =&gt;</span> observer !== func);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">notify</span>(<span class="params">data</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.observers.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> observer(data));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  观察者模式的优点是 <code>observer</code> 能够在任意时间和 <code>observable</code> 进行解耦合，能够很好的实践单一职责原则和关注点分离；缺点就是当<br><code>observer</code>过去复杂时，处理订阅者的逻辑可能会有性能问题。比如说，fn 中的逻辑十分重。</p>
<h2 id="module-模式"><a href="#module-模式" class="headerlink" title="module 模式"></a>module 模式</h2><blockquote>
<p>将一大块逻辑切分成更小的，可复用的模块</p>
</blockquote>
<p>  这个特性其实本身是 <code>ES6</code> 支持的一部分，在之前的 <code>ES5</code>中是没有这种东西的，最多只有function scope，block scope（指with，try catch）。</p>
</div></article></div></main><footer><div class="paginator"><a class="prev" href="/2022/01/13/2021/">上一篇</a><a class="next" href="/2021/12/03/hello-world/">下一篇</a></div><div class="copyright"><p>© 2019 - 2022 <a href="http://olierjs.github.io">TbhT</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/claymcleod/hexo-theme-hermes" target="_blank">hexo-theme-hermes</a>. </p><p>Logo made by <a target="_blank" rel="noopener" href="https://www.flaticon.com/authors/freepik">Freepik</a> from <a target="_blank" rel="noopener" href="https://flaticon.com">www.flaticon.com</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><!-- Global site tag (gtag.js) - Google Analytics --><script async src="https://www.googletagmanager.com/gtag/js?id=GTM-5K584LS"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'GTM-5K584LS');</script></body></html>